/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package backEnd.semantic;

import backEnd.Objects.dataType;
import backEnd.Objects.finalStr.cuarteta;
import backEnd.Objects.finalVar;
import backEnd.Objects.tempFinalVar;
import backEnd.Objects.tempVar;
import backEnd.exceptions.InputsVaciosException;
import java.util.ArrayList;
import java.util.LinkedList;

/**
 *
 * @author angel
 */
public class semanticArray {

    semanticManager semanticM;
    protected LinkedList<cuarteta> temp4thdir = new LinkedList<>();
    int contador = 0;

    public semanticArray(semanticManager semanticM) {
        this.semanticM = semanticM;
    }

    /**
     * This method is to start the list of dimension of the array (The method
     * take the 4 directions code generated by the operation)
     *
     * @param dimension
     * @param line
     * @return
     */
    public LinkedList<tempVar> startDimension(tempVar dimension, int line) {
        if (dimension != null) {
            if (dimension.getCategory() == semanticM.languageC.INTEGER) {
                LinkedList<tempVar> tempArray = new LinkedList<>();
                tempArray.clear();
                tempArray.add(dimension);
                temp4thdir.addAll(semanticM.operations.getTemp4thdir());
                semanticM.operations.resetTemp3VarList();
                return tempArray;
            } else {
                semanticM.operations.sendError(semanticM.languageC.INTEGER_NAME, "Dato incompatible para el arreglo", semanticM.languageC.getDataTypeName(dimension.getCategory()), dimension.getRow());
                return null;
            }
        } else {
            semanticM.operations.sendError(semanticM.languageC.INTEGER_NAME, "Dato incompatible para el arreglo", "Sin dato", line);
            return null;
        }
    }

    /**
     * This method take care to add the the initial list of dimension the next
     * one (The method take the 4 directions code generated by the operation)
     *
     * @param lisntIn
     * @param dimension
     * @param line
     * @return
     */
    public LinkedList<tempVar> startDimension(LinkedList<tempVar> lisntIn, tempVar dimension, int line) {
        if (dimension != null) {
            if (dimension.getCategory() == semanticM.languageC.INTEGER) {
                LinkedList<tempVar> tempArray = new LinkedList<>();
                tempArray.clear();
                if (lisntIn == null) {
                    semanticM.operations.sendError("Revisar errores previos en linea: " + line);
                    return null;
                } else {
                    tempArray.addAll(lisntIn);
                    tempArray.add(dimension);
                    temp4thdir.addAll(semanticM.operations.getTemp4thdir());
                    semanticM.operations.resetTemp3VarList();
                    return tempArray;
                }
            } else {
                semanticM.operations.sendError(semanticM.languageC.INTEGER_NAME, "Dato incompatible para el arreglo", semanticM.languageC.getDataTypeName(dimension.getCategory()), dimension.getRow());
                return null;
            }
        } else {
            semanticM.operations.sendError(semanticM.languageC.INTEGER_NAME, "Dato incompatible para el arreglo", "Sin dato", line);
            return null;
        }
    }

    public tempFinalVar varToSave(String id, LinkedList<tempVar> lisntIn, int line) throws InputsVaciosException {
        if (lisntIn != null) {
            if (lisntIn.size() == 1) {
                temp4thdir.add(new cuarteta(null, id, semanticM.languageC.ARRAY_ID, semanticM.languageC.getID_Value(lisntIn.get(0)), lisntIn));
                return new tempFinalVar(id, new tempVar(semanticM.languageC.NO_TYPE_AUX, 0, 0), lisntIn);
            } else {
                temp4thdir.add(new cuarteta(null, id, semanticM.languageC.ARRAY_ID, addArrayFormula(lisntIn), lisntIn));
                return new tempFinalVar(id, new tempVar(semanticM.languageC.NO_TYPE_AUX, 0, 0), lisntIn);
            }
        } else {
            semanticM.operations.sendError("Revisar errores previos en linea: " + line);
            return null;
        }
    }

    public tempFinalVar varToSave(String id, LinkedList<tempVar> lisntIn, tempVar dato, int line) throws InputsVaciosException {
        finalVar fVar = semanticM.findVariable(id);
        if (lisntIn != null && fVar != null && dato != null) {
            if (fVar.getDimensions() != null) {
                if (lisntIn.size() == fVar.getDimensions().size() && fVar.getdType().getNameData() == dato.getCategory()) {
                    if (dato.getCategory() == semanticM.languageC.BOOLEAN) {
                        return new tempFinalVar(id, dato, lisntIn);
                    } else {
                        if (lisntIn.size() == 1) {
                            temp4thdir.add(new cuarteta(fVar.getdType(), id, semanticM.languageC.ARRAY_ASIGNED_ID, semanticM.languageC.getID_Value(lisntIn.get(0)), semanticM.languageC.getID_Value(dato), lisntIn));
                            return new tempFinalVar(id, dato, lisntIn);
                        } else {
                            temp4thdir.add(new cuarteta(fVar.getdType(), id, semanticM.languageC.ARRAY_ASIGNED_ID, arrayFormula(fVar, lisntIn), semanticM.languageC.getID_Value(dato), lisntIn));
                            return new tempFinalVar(id, dato, lisntIn);
                        }
                    }
                } else {
                    semanticM.operations.sendError("Estructrua de arreglo incorrecta, Linea: " + line);
                    return null;
                }
            } else if (fVar.getdType().getNameData() != dato.getCategory()) {
                semanticM.operations.sendError("Dato imcompatible con " + id + ", Linea: " + line);
                return null;
            } else {
                semanticM.operations.sendError("La variable " + id + " no es un arreglo, Linea: " + line);
                return null;
            }
        } else if (lisntIn == null) {
            semanticM.operations.sendError("No existe un arrglo de entrada, Linea: " + line);
            return null;
        } else if (fVar == null) {
            semanticM.operations.sendError("No existe la variable " + id + ", Linea: " + line);
            return null;
        } else {
            semanticM.operations.sendError("No existe un dato para asignar a " + id + ", Linea: " + line);
            return null;
        }

    }

    public tempFinalVar varToSave(String id1, String id2, LinkedList<tempVar> lisntIn, int line) {
        return null;
    }

    protected String arrayFormula(finalVar existVar, LinkedList<tempVar> lisntIn) throws InputsVaciosException {
        String textFinal = "";
        for (int i = 0; i < lisntIn.size(); i++) {

            String textOut = "";
            if (lisntIn.size() - (i + 1) > 1) {
                for (int j = existVar.getDimensions().size() - 1; j > i; j--) {
                    if (j == existVar.getDimensions().size() - 1) {
                        textOut = semanticM.languageC.ARRAY_LABLE + contador;
                        temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + contador, semanticM.languageC.POR_ID,
                                semanticM.languageC.getID_Value(existVar.getDimensions().get(j)), semanticM.languageC.getID_Value(existVar.getDimensions().get(j - 1))));
                        j--;
                        contador++;
                    } else {
                        temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE
                                + contador, semanticM.languageC.POR_ID, semanticM.languageC.getID_Value(existVar.getDimensions().get(j)), textOut));
                        textOut = semanticM.languageC.ARRAY_LABLE + contador;
                        contador++;
                    }
                }
                temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + contador,
                        semanticM.languageC.POR_ID, semanticM.languageC.getID_Value(lisntIn.get(i)), textOut));
                if (i != 0) {
                    temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + (contador + 1),
                            semanticM.languageC.MAS_ID, textFinal, semanticM.languageC.ARRAY_LABLE + contador));
                    textFinal = semanticM.languageC.ARRAY_LABLE + (contador + 1);
                    contador++;
                } else {
                    textFinal = semanticM.languageC.ARRAY_LABLE + contador;
                }
                contador++;
            } else if (lisntIn.size() - (i + 1) <= 1) {
                if (textFinal.isEmpty()) {
                    temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + contador, semanticM.languageC.POR_ID,
                            semanticM.languageC.getID_Value(existVar.getDimensions().get(existVar.getDimensions().size() - 2)), semanticM.languageC.getID_Value(lisntIn.get(i))));
                    temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + (contador + 1),
                            semanticM.languageC.MAS_ID, semanticM.languageC.ARRAY_LABLE + contador, semanticM.languageC.getID_Value(lisntIn.get(i + 1))));
                    contador += 2;
                } else {
                    temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + contador, semanticM.languageC.POR_ID,
                            semanticM.languageC.getID_Value(existVar.getDimensions().get(existVar.getDimensions().size() - 2)), semanticM.languageC.getID_Value(lisntIn.get(i))));
                    temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + (contador + 1),
                            semanticM.languageC.MAS_ID, semanticM.languageC.ARRAY_LABLE + contador, semanticM.languageC.getID_Value(lisntIn.get(i + 1))));
                    temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + (contador + 2),
                            semanticM.languageC.MAS_ID, semanticM.languageC.ARRAY_LABLE + (contador + 1), textFinal));
                    textFinal = semanticM.languageC.ARRAY_LABLE + (contador + 2);
                    contador += 3;
                }
                i++;
            }
        }
        return textFinal;
    }

    private String addArrayFormula(LinkedList<tempVar> lisntIn) throws InputsVaciosException {
        String textOut = "";
        for (int i = 0; i < lisntIn.size(); i++) {
            if (i == 0) {
                textOut = semanticM.languageC.ARRAY_LABLE + contador;
                temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE + contador,
                        semanticM.languageC.POR_ID, semanticM.languageC.getID_Value(lisntIn.get(i)), semanticM.languageC.getID_Value(lisntIn.get(i + 1))));
                i++;
                contador++;
            } else {
                temp4thdir.add(new cuarteta(semanticM.findDType(semanticM.languageC.INTEGER), semanticM.languageC.ARRAY_LABLE
                        + contador, semanticM.languageC.POR_ID, semanticM.languageC.getID_Value(lisntIn.get(i)), textOut));
                textOut = semanticM.languageC.ARRAY_LABLE + contador;
                contador++;
            }
        }
        return textOut;
    }

    public void reset4dirList() {
        temp4thdir.clear();
    }

    public void resetContador() {
        contador = 0;
    }

    public LinkedList<cuarteta> getTemp4thdir() {
        return temp4thdir;
    }

    public void setTemp4thdir(LinkedList<cuarteta> temp4thdir) {
        this.temp4thdir = temp4thdir;
    }

}
